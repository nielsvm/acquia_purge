<?php

/**
 * @file
 * acquia_purge.module
 * @description
 * Automatically purge pages upon save or the full site from Varnish.
 * @author
 * Niels van Mourik - Acquia Client Advisory <niels.vanmourik@acquia.com>
 */

/**
 * The amount of purge requests Acquia Purge can handle per HTTP request.
 */
define('ACQUIA_PURGE_QUEUE_TRESHOLD', 10);

/**
 * Implements hook_permission().
 */
function acquia_purge_permission() {
  return array(
    'purge notification' => array(
      'title' => t('Purge notification'),
      'description' => t('Get a confirmation message on screen for all items
      that have been purged.'),
    ),
  );
}

/**
 * Implements hook_expire_cache().
 */
function acquia_purge_expire_cache($paths) {

  // The expire module has a interestingly weird option named "Include base URL
  // in expires" which gives us filthy paths with base URL's in it. If its
  // enabled we do our best to strip and clean the paths.
  if (variable_get('expire_include_base_url', EXPIRE_INCLUDE_BASE_URL)) {
    $stripped_paths = array();
    $domains = _acquia_purge_get_domains();
    foreach ($paths as $path) {
      $stripped_path = $path;
      foreach ($domains as $domain) {
        $stripped_path = str_replace("http://$domain", '', $stripped_path);
        $stripped_path = str_replace("https://$domain", '', $stripped_path);
        $stripped_path = ltrim($stripped_path, '/');
      }
      $stripped_paths[] = $stripped_path;
    }
    $paths = $stripped_paths;
  }

  acquia_purge_purge_paths($paths);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function acquia_purge_form_system_performance_settings_alter(&$form, &$form_state, $form_id) {

  // Add a checkbox to the system_performance_settings performance form to allow
  // users to enable/disable purge reporting.
  $checkbox = array();
  $checkbox['#title'] = t('Report cache purges');
  $checkbox['#description'] = t('Whenever something in Drupal gets updated that
    could be remotely cached in Varnish the Acquia Purge module can report this
    to the screen to notify you. Note that you will need to enable the <i>purge
    notification</i> permission first.');
  $checkbox['#default_value'] = variable_get('acquia_purge_reportpurges', TRUE);
  $checkbox['#type'] = 'checkbox';
  $checkbox['#weight'] = -4;
  $form['caching']['acquia_purge_reportpurges'] = $checkbox;
}

/**
 * Determine whether we are running on Acquia Cloud or not.
 *
 * @returns
 *   A boolean expression indicating if we currently run on Acquia cloud.
 */
function _acquia_purge_are_we_on_acquiacloud() {
  static $connected;

  // Build our assertions logic and cache it statically.
  if (is_null($connected)) {
    $assertions = array(
      is_array(variable_get('acquia_hosting_site_info', FALSE)),
      (bool) count(_acquia_purge_get_balancers()),
      (bool) _acquia_purge_get_site_name(),
      (bool) _acquia_purge_get_site_group(),
      function_exists('curl_init'),
    );
    $connected = !in_array(FALSE, $assertions);
  }

  return $connected;
}

/**
 * Get a list of load balancer IP addresses in front of this Acquia Cloud site.
 *
 * @warning
 *   Please note that the returned IP addresses are internal addresses.
 *
 * @returns
 *   Array with string values pointing to every Acquia Cloud load balancer.
 */
function _acquia_purge_get_balancers() {
  static $balancers;

  // Cache the results statically, preventing multiple lookups during runtime.
  if (is_null($balancers)) {
    $balancers = array();
    foreach (variable_get('reverse_proxies', array()) as $ip_address) {
      $balancers[] = $ip_address;
    }
  }

  return $balancers;
}

/**
 * Get a list of defined domains that we can purge for.
 *
 * @returns
 *   Array with string values mapping to all defined DNS domains for this site.
 */
function _acquia_purge_get_domains() {
  static $domains;

  // Statically cache the domains as fetching them once per request is enough.
  if (is_null($domains)) {
    $domains = array();

    // If the configuration key 'acquia_purge_domains' is set we skip automatic
    // detection fully and add that list of domains to be purged.
    if ($acquia_purge_domains = variable_get('acquia_purge_domains', FALSE)) {
      if (is_array($acquia_purge_domains) && count($acquia_purge_domains)) {
        foreach ($acquia_purge_domains as $domain) {
          _acquia_purge_get_domains_add($domain, $domains);
        }

        // Set and return the set of hardcoded domains.
        return $domains;
      }
    }

    // Add the current HTTP_HOST that we're connected to.
    _acquia_purge_get_domains_add($_SERVER['HTTP_HOST'], $domains);

    // Strip an empty absolute URL (which respects $base_url) and make sure
    // that domain is also in the list of domains to be purged.
    $base_domain = url('', array('absolute' => TRUE));
    $base_domain = str_replace('https://', '', $base_domain);
    $base_domain = str_replace('http://', '', $base_domain);
    $base_domain = str_replace('/', '', $base_domain);
    _acquia_purge_get_domains_add($base_domain, $domains);

    // Gather potentially defined domains in sites/sites.php, for this site.
    _acquia_purge_get_domains_add_sitesphp($domains);

    // To better support multi-sites we only load in the configured Acquia Cloud
    // domain names when we are on the 'default' site as that would else flood
    // another site which we don't want to happen, on <front> for example.
    if (($conf_path = conf_path()) == 'sites/default') {

      // Add the domain names the customer defined on Acquia Cloud. When this
      // process would fail we have at least the current + $base_url domain.
      if (_acquia_purge_are_we_on_acquiacloud()) {
        _acquia_purge_get_domains_add_acloud($domains);
      }
    }
  }

  return $domains;
}

/**
 * Add a domain to the domain list after cleaning and checking for duplicates.
 *
 * @param string $domain
 *   The domain string to be added to the list.
 * @param array &$domains
 *   A reference to the array of currently gathered domain names.
 *
 * @returns
 *  Void, data will be added by reference.
 */
function _acquia_purge_get_domains_add($domain, &$domains) {
  $domain = trim(drupal_strtolower($domain));
  if (!empty($domain) && !in_array($domain, $domains)) {
    $domains[] = $domain;
  }
}

/**
 * Expand the list of domains being gathered by those defined in Acquia Cloud.
 *
 * @param array $domains
 *   A reference to the array of currently gathered domain names.
 *
 * @returns
 *   Void, data will be added by reference.
 * @warning
 *   The current implementation of this function is subject to change. @TODO
 */
function _acquia_purge_get_domains_add_acloud(&$domains) {

  // Albeit quite a dirty way, get all domains defined for this site's vhost.
  if (file_exists('/etc/apache2/conf.d')) {
    $site_name = _acquia_purge_get_site_name();
    $server_name = shell_exec("grep -r 'ServerName' /etc/apache2/conf.d/$site_name*.conf");
    foreach (explode('ServerName', $server_name) as $testable) {
      foreach (explode(' ', trim($testable)) as $domain) {
        _acquia_purge_get_domains_add($domain, $domains);
      }
    }
    $server_alias = shell_exec("grep -r 'ServerAlias' /etc/apache2/conf.d/$site_name*.conf");
    foreach (explode('ServerAlias', $server_alias) as $testable) {
      foreach (explode(' ', trim($testable)) as $domain) {
        _acquia_purge_get_domains_add($domain, $domains);
      }
    }
  }
}

/**
 * Expand the list of domains being gathered by interpreting sites/sites.php.
 *
 * @param array $domains
 *   A reference to the array of currently gathered domain names.
 *
 * @returns
 *   Void, data will be added by reference.
 * @warning
 *   The way the sites/sites.php array was designed was to make it a
 *   lookup map with the current active URI as lookup resource, it makes
 *   that relatively easy to do. However, we want to get all domains that
 *   point to the currently chosen site. As the array keys are in the
 *   format of '<port>.<domain>.<path>' this is relatively hackish.
 */
function _acquia_purge_get_domains_add_sitesphp(&$domains) {
  $sitedir = str_replace('sites/', '', conf_path());

  // Only interpret the $sites array if the file sites/sites.php exists.
  if (!file_exists('sites/sites.php')) {
    return;
  }

  // Define the full list of TLD's we have to check against to determine if a
  // embedded domain name in '<port>.<domain>.<path>' seems valid for us.
  include drupal_get_path('module', 'acquia_purge') . '/acquia_purge.tlds.inc';

  // Include the file which will (re)propagate the $sites array for us.
  $sites = array();
  include 'sites/sites.php';

  // Protect ourselves against badly written code inside sites.php.
  if ((!isset($sites)) || empty($sites)) {
    return;
  }

  // Iterate and validate each record in the resulting $sites array.
  foreach ($sites as $site => $directory) {

    // Skip those that point to a different site directory then we are on.
    if ($directory != $sitedir) {
      continue;
    }

    // Split $site that can be defined in the form of '<port>.<domain>.<path>'.
    $site = explode('.', $site);

    // Strip TCP port's in '<port>....'.
    if (is_numeric($site[0])) {
      unset($site[0]);
    }

    // We skip all $site records which don't end on a common known TLD, examples
    // would be '8080.localhost', 'www.drupal.org.my.dir' and every other site
    // that's defined with a path appended to it. It's an unfortunate limitation
    // but a very hard thing to support, so checking on TLD's is the only
    // sensible thing we can do to support as much scenario's as possible.
    if (!in_array(end($site), $tlds)) {
      continue;
    }

    // What's left should be a 99.99% correct domain name we want to see purged.
    _acquia_purge_get_domains_add(implode('.', $site), $domains);
  }
}

/**
 * Determine the Acquia site name.
 *
 * @returns
 *   Either a boolean FALSE or a string identifying what site we are on.
 */
function _acquia_purge_get_site_name() {
  static $ah_site_name;
  if (is_null($ah_site_name)) {
    $ah_site_name = FALSE;
    if (isset($_ENV['AH_SITE_NAME']) && !empty($_ENV['AH_SITE_NAME'])) {
      $ah_site_name = $_ENV['AH_SITE_NAME'];
    }
  }
  return $ah_site_name;
}

/**
 * Determine the Acquia site group.
 *
 * @returns
 *   Either a boolean FALSE or a string identifying what site group this is.
 */
function _acquia_purge_get_site_group() {
  static $ah_site_group;
  if (is_null($ah_site_group)) {
    $ah_site_group = FALSE;
    if (isset($_ENV['AH_SITE_GROUP']) && !empty($_ENV['AH_SITE_GROUP'])) {
      $ah_site_group = $_ENV['AH_SITE_GROUP'];
    }
  }
  return $ah_site_group;
}

/**
 * Queue manager: return the queue object in use for Acquia Purge.
 *
 * @returns
 *   Queue object as generated by DrupalQueue::get().
 */
function _acquia_purge_queue() {
  static $queue;

  // We cache the queue object statically so create it once per HTTP request.
  if (is_null($queue)) {
    $queue = DrupalQueue::get('acquia_purge', TRUE);
  }

  return $queue;
}

/**
 * Queue manager: add a single purge to the queue.
 *
 * @param string $path
 *   The Drupal path (e.g. '<front>', 'user/1' or an aliased path).
 * @param string $domain
 *   The domain that has to be purged.
 * @param string $balancer_ip
 *   The IP address of the balancer from which the URI should be purged.
 *
 * @returns
 *   The total amount of items in the queue (int).
 */
function _acquia_purge_queue_add($path, $domain, $balancer_ip) {
  $qcount = variable_get('acquia_purge_queue_counter', 0);
  $queue = _acquia_purge_queue();

  // Add the non-associative purge item definition.
  $queue->createItem(array($path, $domain, $balancer_ip));

  // Bump the queue counter.
  $qcount++;

  // Store the queue counter in our state variable.
  variable_set('acquia_purge_queue_counter', $qcount);

  return $qcount;
}

/**
 * Queue manager: pop X amount of items from the queue.
 *
 * @param string $processor_callback
 *   The name of a PHP function or callable that gets called to process a
 *   individual item popped from the queue. The callback is given the path as
 *   the first argument, the domain as second and the balancer IP as third. This
 *   parameter is optional.
 *
 * @warning
 *   Calling this helper commits the caller into actually processing the items
 *   popped from the queue, either by iterating the return value or by providing
 *   a processing callback that processes individual values. Not processing the
 *   result will lead into confusion and broken functionality.
 * @returns
 *   Non-associative array of which every value record represents one resulting
 *   HTTP PURGE request. Array items are non-associative arrays itself with the
 *   path as key #0, the domain as key #1 and the balancer ip address as key #2.
 */
function _acquia_purge_queue_pop($processor_callback = NULL) {
  $qcount = variable_get('acquia_purge_queue_counter', 0);
  $queue = _acquia_purge_queue();
  $items = array();

  // Retrieve as much items as defined in ACQUIA_PURGE_QUEUE_TRESHOLD.
  for ($i=0; $i < ACQUIA_PURGE_QUEUE_TRESHOLD; $i++) {
    if ($item = $queue->claimItem()) {
      $items[] = $item->data;
      $queue->deleteItem($item);

      // Call the callback once provided and pass on the arguments to purge.
      if (!is_null($processor_callback)) {
        call_user_func_array($processor_callback, $item->data);
      }
    }
  }

  // Set acquia_purge_queue_counter to 0 once the queue is empty as well.
  if ((int) $queue->numberOfItems() === 0) {

    // Once its back to 0, progress is 100% and no activity is assumed.
    variable_set('acquia_purge_queue_counter', 0);
  }

  return $items;
}

/**
 * Queue manager: generate progress statistics on the purge queue.
 *
 * @returns
 *   Associative array with the keys 'running', 'total', 'remaining',
 *   'processed', 'percentage'.
 */
function _acquia_purge_queue_stats() {
  $queue = _acquia_purge_queue();

  // Initialize array with default values, except for the total counter.
  $info = array(
    'total' => variable_get('acquia_purge_queue_counter', 0),
    'remaining' => 0,
    'processed' => 0,
    'percentage' => 100,
    'running' => FALSE);

  // Cut statistics gathering when the queue counter equals 0: not running.
  if ($info['total'] === 0) {
    return $info;
  }

  // Once we are here there are jobs running, lets update that.
  $info['running'] = TRUE;

  // Add 'remaining' and 'processed' counters.
  $info['remaining'] = (int) $queue->numberOfItems();
  $info['processed'] = $info['total'] - $info['remaining'];

  // Calculate the percentage of the job.
  $info['percentage'] = ($info['remaining']/$info['total']) * 100;
  $info['percentage'] = (int) (100 - floor($info['percentage']));

  return $info;
}

/**
 * Purge the paths from a node from Varnish.
 *
 * @param object $node
 *   A Drupal node object that was just inserted or saved.
 * @param array $domains
 *   Array containing all the domain names the record should be purged
 *   from. Optional, default list of domain names will be generated else.
 *
 * @returns
 *   Boolean TRUE indicating success, boolean FALSE indicating FAILURE.
 */
function acquia_purge_purge_node(&$node, $domains = NULL) {

  // Purge updated nodes from all domains in Varnish.
  $paths = array('node/' . $node->nid);
  if (isset($node->path['alias']) && !empty($node->path['alias'])) {
    $paths[] = $node->path['alias'];
  }
  if (isset($node->promote) && $node->promote) {
    $paths[] = '<front>';
    $paths[] = 'rss.xml';
  }
  acquia_purge_purge_paths($paths);
}

/**
 * Purge a certain Drupal path from Varnish.
 *
 * @param string $path
 *   The Drupal path (e.g. '<front>', 'user/1' or an aliased path).
 * @param array $domains
 *   Array containing all the domain names the record should be purged
 *   from. Optional, default list of domain names will be generated else.
 *
 * @returns
 *   Boolean TRUE indicating success, boolean FALSE indicating FAILURE.
 */
function acquia_purge_purge_path($path, $domains = NULL) {

  // Refuse execution whenever we are outside Acquia Cloud.
  if (!_acquia_purge_are_we_on_acquiacloud()) {

    // When our detection logic tells us we are not on Acquia Cloud we want to
    // log a failed purge attempt and include debugging information (#2000824).
    watchdog(
      'acquia_purge',
      "Failed attempt to purge '%path' because we don't seem to be on Acquia "
        . "Cloud, debugging information: site-info-is-array='%site_info', curl-"
        . "init-function-exists='%curl_init', env-vars=(%env-vars), sapi=%sapi",
      array(
        '%path' => $path,
        '%site_info' => strip_tags(var_export(is_array(variable_get('acquia_hosting_site_info', FALSE)), TRUE)),
        '%curl_init' => strip_tags(var_export(function_exists('curl_init'), TRUE)),
        '%env-vars' => strip_tags(var_export($_ENV, TRUE)),
        '%sapi' => php_sapi_name()),
      WATCHDOG_WARNING);

    return FALSE;
  }

  // Get a list of domains ourselves when these are not given.
  if (is_null($domains)) {
    $domains = _acquia_purge_get_domains();
  }

  // The special path '<front>' links to the default front page.
  if ($path == '<front>') {
    $path = '';
  }

  // Declare $base_path and $site_name, we use it inside our domain loop.
  $base_path = base_path();
  $site_name = _acquia_purge_get_site_name();

  // Log the path about to be purged and its domains.
  watchdog('acquia_purge', 'Purged path "%path" on these domains: %domains.',
    array('%path' => $path, '%domains' => implode(', ', $domains)));

  // Collect each execution result to be able to determine the return value.
  $results = array();

  // Loop through each domain and generate a URL to send the PURGE header to.
  foreach ($domains as $domain) {
    $headers = array("Accept-Encoding: gzip", "X-Acquia-Purge:$site_name");

    // Construct the URI to be purged and prevent theoretical double slashes.
    $uri = $domain . $base_path . $path;
    $uri = 'http://' . str_replace('//', '/', $uri);

    // Configure the curl resource.
    $curl = curl_init();
    curl_setopt($curl, CURLOPT_URL, $uri);
    curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);
    curl_setopt($curl, CURLOPT_CUSTOMREQUEST, 'PURGE');
    curl_setopt($curl, CURLOPT_FAILONERROR, TRUE);

    // Execute the PURGE header and add up to the results.
    $results[] = curl_exec($curl);

    // Close the curl session.
    curl_close($curl);

    // To be certain we also clear any records from the cache_page bin.
    cache_clear_all($uri, 'cache_page');

    // Notify the user if he requested this.
    if (variable_get('acquia_purge_reportpurges', TRUE)
      && user_access('purge notification')) {
      drupal_set_message(t("Purged from Varnish: <b>@uri</b>", array('@uri' => $uri)), 'info');
    }
  }

  return !in_array(FALSE, $results);
}

/**
 * Purge a several Drupal paths from Varnish.
 *
 * @param string $paths
 *   Array with Drupal paths (e.g. '<front>', 'user/1' or an aliased path).
 * @param array $domains
 *   Array containing all the domain names the record should be purged
 *   from. Optional, default list of domain names will be generated else.
 *
 * @returns
 *   Boolean TRUE indicating success, boolean FALSE indicating FAILURE.
 */
function acquia_purge_purge_paths($paths, $domains = NULL) {
  $results = array();
  foreach ($paths as $path) {
    $results[] = acquia_purge_purge_path($path, $domains);
  }
  return !in_array(FALSE, $results);
}
